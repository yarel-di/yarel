/**
 * Yarel
 * Copyright (C) 2018  Claudio Grandi, Dariush Moshiri, Luca Roversi
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


grammar org.di.unito.yarel.Yarel with org.eclipse.xtext.common.Terminals

generate yarel "http://www.di.org/unito/yarel/Yarel"

Model:
    imports += Import* 'module' name=ID '{' elements+=Element* '}'; //Changed by Matteo Palazzo
	
Element: 
	  Declaration | Definition;

Import:
	'import' importedNamespace=QualifiedNameWithWildcard; //Changed by Matteo Palazzo

QualifiedName:
   ID ('.' ID)*;

QualifiedNameWithWildcard:
    ID ('.' ID)* '.' (ID | '*');  //Changed by Matteo Palazzo

Declaration:
	'dcl' name=ID 
	( '(' invocParamsSignat = InvocationParametersSignature ')')?
	':'
	aritySignature = AritySignature
	;

InvocationParametersSignature:
	invocParam += TypeParam (',' invocParam += TypeParam)*
;

AritySignature:
	types += Type (',' types+=Type)*
	(',' parametricArities += TypeParam (',' parametricArities += TypeParam)* )?
	;

Type: 
    {Type} value=(INT)? 'int';

TypeParam: // "int" type assumed 
	{TypeParam} parName=ID;

Definition:
	'def' declarationName=[Declaration] ':=' body=Body;

Body: SerComp;

SerComp returns Body:
	ParComp ({SerComp.left=current} ';' right=ParComp)*;

ParComp returns Body:
	BodyBase ({ParComp.left=current} '|' right=BodyBase)* ;

BodyBase returns Body: 
   '(' Body ')' | Atomic;

Permutation: 
  '/' indexes+=Digit (indexes+=Digit)* '/';
 

FunctionInvocation:
	funName=[Declaration | QualifiedName]
	( aritiesAssign = AritiesAssignment)?
	( paramsAssign = ParametersAssignment)?
;

AritiesAssignment:
	'{' arities += ParametricArity ((',' arities+=ParametricArity)*) '}'
;


ParametersAssignment:
	'(' parameters += ParametricArity (',' parameters+=ParametricArity)* ')'
;

/**
 * Indexes are 1-based.
 */
Atomic returns Body: 
    {BodyId}  funName ='id' 
  | {BodyInc} funName ='inc' 
  | {BodyDec} funName ='dec'
  | {BodyNeg} funName ='neg'
  | {BodyFor} function='for' '[' body=Body ']'
  | {BodyInv} function='inv' '[' body=Body ']'
  | {BodyIt}  function='it' '[' body=Body ']'
  | {BodyIf}  function='if' '[' pos=Body ',' zero=Body ',' neg=Body ']'
  | {BodyFun} function=FunctionInvocation
  | {BodyPerm} permutation=Permutation
//  | {BodySwap}function= SwapIndexed
  | AtomicParametricArity
;


AtomicParametricArity returns Body:
	  AtomicParArityOperator
	| AtomicParametricRepetition
	| {BodySwap} function = SwapIndexed
;

AtomicParArityOperator returns Body:
	  ({BodyParamPerm}        '/' arity = AritiesAssignment '/') // the total arity is: "1 (the index's register) + permutationAriety (desired permutation's arity)".
	| ({BodyParamId} funName='id' arity = AritiesAssignment)
;

AtomicParametricRepetition returns Body:
	AtomicParRep
	arity = AritiesAssignment
	( paramsAssign = ParametersAssignment )? // "repetitions" values could be taken from funtion's "invocation parameters" or "arity parameters"
;

AtomicParRep :
	  {BodyParamInc} funName='inc'
	| {BodyParamDec} funName='dec'
	| {BodyParamNeg} funName='neg'
;

SwapIndexed : // requires also 1 more register (for RPP-like implementations)
//	{SwapIndexed}
	funName= 'swap'
	arity = AritiesAssignment
	paramsAssign = ParametersAssignment
;


ParametricArity:
	arity = LinearExpressionWithParameters
;


/** LINEAR EXPRESSION (enhanced with parameters)
 * 
 * Note:
 * right now, only additions and subtractions are allowed and implemented.
 * */

LinearExpressionWithParameters:
	LEWP
;

LEWP returns LinearExpressionWithParameters:
	BinaryArgLEWP (
		({AdditionLEWP.left = current} '+' right = BinaryArgLEWP)
		|({SubtractionLEWP.left = current} '-' right = BinaryArgLEWP)
	)*
;

BinaryArgLEWP returns LinearExpressionWithParameters:
	PlusLEWP | MinusLEWP | BranchLEWP
;


MinusLEWP returns LinearExpressionWithParameters:
	{MinusLEWP} '-' sub = BranchLEWP
;

PlusLEWP returns LinearExpressionWithParameters:
	{PlusLEWP} '+' sub = BranchLEWP
;

BranchLEWP returns LinearExpressionWithParameters:
	BracketLEWP | AtomLEWP 
;

AtomLEWP returns LinearExpressionWithParameters:
	  {IntLEWP}   value = Digit
	| {ParamLEWP} value = ParameterLEWP
;

BracketLEWP:
	'(' sub= LinearExpressionWithParameters ')'
;

ParameterLEWP:
	paramName = ID
;

Digit:
	value=INT;