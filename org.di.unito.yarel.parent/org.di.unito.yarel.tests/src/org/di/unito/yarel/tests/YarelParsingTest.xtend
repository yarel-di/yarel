/*
 * generated by Xtext 2.10.0
 */
/*Added by Paolo Parker*/
package org.di.unito.yarel.tests

import static extension org.eclipse.xtext.EcoreUtil2.*

import static extension org.junit.Assert.*
import org.junit.runner.RunWith
import javax.inject.Inject
import org.junit.Test
import org.di.unito.yarel.yarel.Model
import org.di.unito.yarel.yarel.Definition
import org.di.unito.yarel.yarel.Declaration
import org.di.unito.yarel.yarel.Body
import org.di.unito.yarel.yarel.SerComp
import org.di.unito.yarel.yarel.ParComp
import org.di.unito.yarel.yarel.BodyInc
import org.di.unito.yarel.yarel.BodyDec
import org.di.unito.yarel.yarel.BodyFun
import org.di.unito.yarel.yarel.BodyPerm
import org.di.unito.yarel.yarel.Type
import org.di.unito.yarel.yarel.Signature
import java.util.ArrayList
import org.di.unito.yarel.yarel.Permutation
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.di.unito.yarel.yarel.BodyFor
import org.di.unito.yarel.yarel.BodyIt
import org.di.unito.yarel.yarel.BodyInv
import org.di.unito.yarel.yarel.BodyIf
import org.di.unito.yarel.yarel.BodyId

@RunWith(XtextRunner)
@InjectWith(YarelInjectorProvider)

class YarelParsingTest
{
	@Inject extension ParseHelper<Model> //Utility class that contains various methods to facilitate parsing testing
    @Inject extension ValidationTestHelper //Utility class that contains various methods to facilitate validation testing

//-------------------------------------------SUPPORT METHODS----------------------------------------------------------
	// ---------------------------------------------------------
   // ----------- Pretty-printing reconstruction of the grammar.
   
	def private String stringModelRepr(Model m)
	{
		var r = "module " + m.name + " {"
		for(var i = 0; i < m.elements.length; i++)
		{
			if(m.elements.get(i).getContainerOfType(Declaration)!==null)
			{
			   r = r + stringDeclarationRepr(m.elements.get(i) as Declaration)
			}
			
			if(m.elements.get(i).getContainerOfType(Definition)!==null)
			{
			   r = r + stringDefinitionRepr(m.elements.get(i) as Definition)			
			}
		}
		return r + "}"
    }
    
	//Builds and returns a string that represents a Declaration as if it was written in a .rl file
	def private String stringDeclarationRepr(Declaration d) 
	{
          ''' dcl «d.name» : «d.signature.stringSignatureRepr»'''
    }

    /* Wrapper for translating a Signature. It starts 
       the translation of the Type from position 0.*/
	def private String stringSignatureRepr(Signature s) 
	{
		'''«stringSignatureRepr(s, 0)»'''
    }

	/*Builds and returns a string containing data type names, each separated by a comma.
	  As the grammar says, a signature can contain multiple type statements, so this
	  method recursively cycles through each type contained in Signature s.
	  You can think of Signature as an array of Types*/
	def private String stringSignatureRepr(Signature s, int i) 
	{
		// BE CAREFUL WHEN REARRANGING THE LAYOUT OF THE FOLLOWING LINE.
		'''«s.types.get(i).stringTypeRepr»«IF i + 1 < s.types.length», «stringSignatureRepr(s, i + 1)»«ENDIF»'''
    }

    //Builds and returns a string containing the name of Type t passed in as parameter.
	def private String stringTypeRepr(Type t) 
	{		
		switch (t) 
		{
			Type : '''int''' 
		}
    }
	
	//Builds and returns a string containing a Definition. For example: "def f := inc" without quotes.
	def private String stringDefinitionRepr(Definition d) 
	{
          ''' def «d.declarationName.name» := «d.body.stringBodyRepr»'''
    }

    /* Reconstructs the string that pretty prints the content of Body.
     * The 'pretty-printing' amounts to insert parenthesis around the 
     * sequential composition. This highlights that it is left-associative.
     * 
     * It's necessary to pay attention to the spaces both
     * in stringBodyRepr and the arguments of assertBodyRepr!!
     * */ 
    def private String stringBodyRepr(Body b) 
    {
        switch (b) 
        {
          SerComp: '''(«b.left.stringBodyRepr»;«b.right.stringBodyRepr»)''' //returns the body wrapped in brackets
          ParComp: '''(«b.left.stringBodyRepr»|«b.right.stringBodyRepr»)''' //returns the body wrapped in brackets
          BodyInc: '''«b.funName»'''
          BodyDec: '''«b.funName»'''
          BodyId: '''«b.funName»'''
          BodyInv: '''inv[«stringBodyRepr(b.body)»]'''
          BodyIt: '''it[«stringBodyRepr(b.body)»]'''
          BodyFor: '''for[«stringBodyRepr(b.body)»]'''
          BodyIf: '''if[«stringBodyRepr(b.pos)»,«stringBodyRepr(b.zero)»,«stringBodyRepr(b.neg)»]'''
          BodyFun: '''«b.funName.name»'''
          BodyPerm: '''/«b.permutation.stringBodyPermRepr»/'''
        }.toString
    }
	
	/*Wrapper for translating a permutation*/
	def private String stringBodyPermRepr(Permutation p)
	{
		stringBodyPermRepr(p, 0)
    }

	/*Builds and returns a string containing the representation of a permutation
	  as if it was written in a .rl file, by recursively cycling through the indices.
	  You can view a Permutation as an array of Indices (as written in the grammar)*/
	def private String stringBodyPermRepr(Permutation p, int i) 
	{
		// BE CAREFUL WHEN REARRANGING THE LAYOUT OF THE FOLLOWING LINE.
		'''«p.indexes.get(i).value»«IF i + 1 < p.indexes.length» «stringBodyPermRepr(p, i + 1)»«ENDIF»'''
    }
   
   // ---------------------------------------------------------------------------
   // ------ Assertions about the equivalence between pretty-printing and input.
	/* Translates Module.
	 * The input and the output contain the syntax of a whole module.
	 */
    def private assertModuleRepr(CharSequence input, CharSequence expected) 
    {
         assertEquals(expected,stringModelRepr(input.parse))
    }

	/* Translates the list of Declarations and Definition in an Element.
	 * The input contains a sequence of declarations and definitions like 
	 * in "dcl f : int def f := inc dcl g : int, bool".
	 * The output contains a list whose elements list in the same order the same 
	 * declarations and definitions. Following the above example, it is
	 * ["dec f : int", "def f := inc", "dec g : int, bool"].
	 */
    def private assertDclDefRepr(CharSequence input, ArrayList<CharSequence> expected) 
    {
    	for(var i = 0; i < expected.length; i++) 
    	{
    	   var element = parse("module m { " + input + "}").elements.get(i)
    	   if (element.getContainerOfType(Declaration)!==null) 
    	   {
    	   		expected.get(i).assertEquals(stringDeclarationRepr(element as Declaration))
    	   }
    	   
    	   if (element.getContainerOfType(Definition)!==null) 
    	   {
    	   		expected.get(i).assertEquals(stringDefinitionRepr(element as Definition))
    	   }
    	}
    }

    /* The parameters input and expected are intended to reference two identical strings
     * containing an example of signature. For example, "int" or "int, int". 
     * It checks if they are effectively identical.
     */
    def private assertSignatureRepr(CharSequence input, CharSequence expected) 
    {
         expected.assertEquals(stringSignatureRepr(((("module m { dcl f:" + input + "}").parse.elements.head) as Declaration).signature))
    }

    /* The parameters input and expected are intended to reference two identical strings
     * containing an example of body. For example, "dec" or "f1;inc" or 
     * "((dec;f0);(inc;dec))". It checks if they are effectively identical.
     */
    def private assertBodyRepr(CharSequence input, CharSequence expected)
    {
    	assertEquals(expected, stringBodyRepr(((("module m { dcl f0: int dcl f1 : int def f0 := " + input + "}").parse.elements.last)as Definition).body))
    }
	
//-----------------------------------------------TESTING-----------------------------------------------------
	
	//iteration tests		
	@Test
	def void testItSerCompBodyOK() 
	{
		assertBodyRepr("it[inc;dec]","it[(inc;dec)]")
	}
	
	@Test
	def void testItParCompBodyOK() 
	{
		assertBodyRepr("it[inc|dec]","it[(inc|dec)]")
	}
	
	@Test
	def void testItInvBodyOK() 
	{
		assertBodyRepr("it[inv[inc]]","it[inv[inc]]")
	}
	
	@Test
	def void testItSerOK() 
	{
		assertBodyRepr("it[inc];it[dec]","(it[inc];it[dec])")
	}
	
	@Test
	def void testItParOK() 
	{
		assertBodyRepr("it[inc]|it[dec]","(it[inc]|it[dec])")
	}
	
	@Test
	def void testItNested0OK() 
	{
		assertBodyRepr("it[it[inc]]","it[it[inc]]")
	}
	
	@Test
	def void testItNested1OK() 
	{
		assertBodyRepr("it[it[it[inc]]]","it[it[it[inc]]]")
	}
	
	//for loop tests
	@Test
	def void testForSerCompBodyOK() 
	{
		assertBodyRepr("for[inc;dec]","for[(inc;dec)]")
	}
	
	@Test
	def void testForParCompBodyOK() 
	{
		assertBodyRepr("for[inc|dec]","for[(inc|dec)]")
	}
	
	@Test
	def void testForInvBodyOK() 
	{
		assertBodyRepr("for[inv[inc]]","for[inv[inc]]")
	}
	
	@Test
	def void testForSerOK() 
	{
		assertBodyRepr("for[inc];for[dec]","(for[inc];for[dec])")
	}
	
	@Test
	def void testForParOK() 
	{
		assertBodyRepr("for[inc]|for[dec]","(for[inc]|for[dec])")
	}
	
	@Test
	def void testForNested0OK() 
	{
		assertBodyRepr("for[for[inc]]","for[for[inc]]")
	}
	
	@Test
	def void testForNested1OK() 
	{
		assertBodyRepr("for[for[for[inc]]]","for[for[for[inc]]]")
	}
	
	//inverse function tests
	@Test
	def void testInvSerCompBodyOK() 
	{
		assertBodyRepr("inv[inc;dec]","inv[(inc;dec)]")
	}
	
	@Test
	def void testInvParCompBodyOK() 
	{
		assertBodyRepr("inv[inc|dec]","inv[(inc|dec)]")
	}
	
	@Test
	def void testInvInvBodyOK() 
	{
		assertBodyRepr("inv[inv[inc]]","inv[inv[inc]]")
	}
	
	@Test
	def void testInvSerOK()
	{
		assertBodyRepr("inv[inc];inv[dec]","(inv[inc];inv[dec])")
	}
	
	@Test
	def void testInvParOK()
	{
		assertBodyRepr("inv[inc]|inv[dec]","(inv[inc]|inv[dec])")
	}
	
	@Test
	def void testInvNested0OK()
	{
		assertBodyRepr("inv[inv[inc]]","inv[inv[inc]]")
	}
	
	@Test
	def void testInvNested1OK()
	{
		assertBodyRepr("inv[inv[inv[inc]]]","inv[inv[inv[inc]]]")
	}
	
	//If tests
	@Test
	def void testIfSerParCompOK()
	{
		assertBodyRepr("if[inc;dec,inc|dec,inv[inc];inv[dec]]", "if[(inc;dec),(inc|dec),(inv[inc];inv[dec])]")
	}
	
	@Test
	def void testDclDefOK()
	{
		"module m { dcl f0 :  int
                    def f0 := inc}".parse.assertNoErrors
	}

	@Test
	def void testSerCompWithConstantsOK() 
	{
		"module m { dcl f0 : int
                    def f0 := inc;dec}".parse.assertNoErrors
	}

	@Test
	def void testSerCompComplexOK() 
	{
		"module m { dcl f0 :  int			
                    dcl f1 :  int
					def f1 := id
                    dcl f2 :  int
					def f2 := id
                    def f0 := (f2;(f2;f1;dec));inc}".parse.assertNoErrors
	}

	@Test
	def void testParCompOK()
	{
		"module m { dcl f0 :  int, int, int, int, int
                    dcl f1 :  int
					def f1 := id
                    dcl f2 :  int
					def f2 := id
                    def f0 := (f2|f1)|((f1|f2)|inc)}".parse.assertNoErrors
	}

	@Test
	def void testSeqParCompOK00() 
	{
		"module m { dcl f0 :  int
					def f0 := id
                    dcl f1 :  int
					def f1 := id
                    dcl f2 :  int, int
                    def f2 := (inc|f0);(f1|dec)}".parse.assertNoErrors
	}
	
	@Test
	def void testSeqParCompOK01() 
	{
		"module m { dcl f0 :  int
					def f0 := id
                    dcl f1 :  int
					def f1 := id
                    dcl f2 :  int, int
                    def f2 := (inc;f1)|(f0;dec)}".parse.assertNoErrors
	}

	@Test
	def void testSeqParCompOK02() 
	{
		"module m { dcl f0 :  int
					def f0 := id
                    dcl f1 :  int
					def f1 := id
                    dcl f2 :  int, int
                    def f2 := (inc;(f1;inc))|(f0;(dec;dec))}".parse.assertNoErrors
	}

	@Test
	def void testPerm00OK() 
	{
		"module m { dcl f0 :  int, int, int
                    def f0 := /3 2 1/}".parse.assertNoErrors
	}

	@Test
	def void testPerm01OK() 
	{
		"module m { dcl f0 :  int
                    def f0 := /1/;(/1/;/1/)}".parse.assertNoErrors
	}

	@Test
	def void testPerm02OK() 
	{
		"module m { dcl f0 :  int, int
                    def f0 := /1/|(/1/;/1/)}".parse.assertNoErrors
	}

//Basic functions tests   
	
	@Test
	def void testIncOK() 
	{
		assertBodyRepr("inc","inc")
	}
	
	@Test
	def void testDecOK() 
	{
		assertBodyRepr("dec","dec")
	}
	
	@Test
	def void testIdOK() 
	{
		assertBodyRepr("id","id")
	}

	@Test
	def void testPermIdOK() 
	{
		assertBodyRepr("/1/","/1/")
	}

	@Test
	def void testPermIdIdOK() 
	{
		assertBodyRepr("/1 2/","/1 2/")
	}

	@Test
	def void testSerComp00OK() 
	{
		assertBodyRepr("inc;dec;inc","((inc;dec);inc)")
	}

	@Test
	def void testSerComp01OK() 
	{
		assertBodyRepr("f1;f0;inc","((f1;f0);inc)")
	}

	@Test
	def void testSerComp02OK() 
	{
		assertBodyRepr("(f1;f0);(inc;dec)","((f1;f0);(inc;dec))")
	}

	@Test
	def void testParComp00OK() 
	{
		assertBodyRepr("inc|dec|inc","((inc|dec)|inc)")
	}

	@Test
	def void testParComp01OK() 
	{
		assertBodyRepr("f1|f0|inc","((f1|f0)|inc)")
	}

	@Test
	def void testParComp02OK() 
	{
		/*The expected value is the function wrapped in brackets because that's how it's defined in
		 * the stringBodyRepr function. The string representing the function wrapped in brackets
		 * (in case of a serial and parallel composition) is returned from that method.*/
		assertBodyRepr("(f1|f0)|(inc|dec)","((f1|f0)|(inc|dec))")
	}

	@Test
	def void testSignatureSingleOK() 
	{
		assertSignatureRepr("int","int")
	}
	
	@Test
	def void testSignatureDoubleOK() 
	{
		assertSignatureRepr("int, int","int, int")
	}

	@Test
	def void testSingleDclSingleTypeOK() {
		assertDclDefRepr("dcl f0 : int", newArrayList(" dcl f0 : int"))
	}
	
	@Test
	def void testSingleDclDoubleType00OK() 
	{
		assertDclDefRepr("dcl f0 : int, int", newArrayList(" dcl f0 : int, int"))
	}
	
	@Test
	def void testSingleDclDoubleType01OK() 
	{
		assertDclDefRepr("dcl f0 : int, int", newArrayList(" dcl f0 : int, int"))
	}
	
	@Test
	def void testDoubleDclSingleTypeOK() 
	{
		assertDclDefRepr("dcl f0 : int dcl f1 : int", newArrayList(" dcl f0 : int", " dcl f1 : int"))
	}
	
	@Test
	def void testDoubleDclDoubleTypeOK() 
	{
		assertDclDefRepr("dcl f0 : int, int dcl f1 : int", newArrayList(" dcl f0 : int, int", " dcl f1 : int"))
	}

	@Test
	def void testInterleavedDclDef() 
	{
		assertDclDefRepr("dcl f : int def f := inc dcl h : int, int dcl g : int def g := dec", newArrayList(" dcl f : int"," def f := inc"," dcl h : int, int"," dcl g : int"," def g := dec"))
	}

	@Test
	def void testModuleEmptyOK()
	{
		assertModuleRepr("module m {}","module m {}")
	}

	@Test
	def void testDeclarationAloneOK() 
	{
		assertModuleRepr("module m { dcl f : int}", "module m { dcl f : int}")
	}

	@Test
	def void testSerCompWithReferenceOK()
	{
		assertModuleRepr("module m { dcl f0 : int dcl f1 : int def f1 := f0;inc}", "module m { dcl f0 : int dcl f1 : int def f1 := (f0;inc)}")
	}

	@Test
	def void testParCompWithReferenceOK() 
	{
		assertModuleRepr("module m { dcl f0 : int dcl f1 : int, int def f1 := f0|inc}", "module m { dcl f0 : int dcl f1 : int, int def f1 := (f0|inc)}")
	}
	
	//TEST FOR IMPORTS
	//Added by: Matteo Palazzo
	
	//Test if there are no error when not using an import
	@Test def void testNoImport(){
		'''
		module mod{
			dcl f : int
			def f := id
			
			dcl g : int
			def g := f
		}
		'''.parse.assertNoErrors
	}
	
	//Test if you can use a function declared in the same module by calling it with the qualified name
	@Test def void testQualifiedNameOfSameModule(){
		'''
		module mod{
			dcl f : int
			def f := id
			
			dcl g : int
			def g := mod.f
		}
		'''.parse.assertNoErrors
	}
}